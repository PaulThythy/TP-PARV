#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec3 position;
    vec3 velocity;
    float weight;
    int isFixed;
};

layout(std430, binding = 0) buffer ParticlesBuffer {
    Particle particles[];
};

uniform float dt;
uniform vec3 gravity;
uniform int NX;
uniform int NY;
uniform float k;           // Constante de ressort
uniform float restLength;  // Longueur de repos des ressorts
uniform vec3 wind;         // Force du vent

int index(int i, int j) {
    return i * NX + j;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    int total = NX * NY;
    if (idx >= uint(total)) return;
    
    Particle p = particles[idx];
    
    // Ne pas mettre à jour les particules fixées
    if (p.isFixed == 1) {
        return;
    }
    
    // Calculer les coordonnées de grille
    int i = int(idx) / NX;
    int j = int(idx) % NX;
    
    vec3 force = vec3(0.0);
    
    // Force externe : gravité
    force += p.weight * gravity;
    // Force externe : vent (ici, on considère le vent comme une force uniforme)
    force += wind;
    
    // Ressorts structurels : voisins haut, bas, gauche et droite
    if (i > 0) {
        Particle neighbor = particles[index(i-1, j)];
        vec3 delta = p.position - neighbor.position;
        float dist = length(delta);
        if (dist > 0.0) {
            vec3 dir = delta / dist;
            float x = dist - restLength;
            force += -k * x * dir;
        }
    }
    if (i < NY - 1) {
        Particle neighbor = particles[index(i+1, j)];
        vec3 delta = p.position - neighbor.position;
        float dist = length(delta);
        if (dist > 0.0) {
            vec3 dir = delta / dist;
            float x = dist - restLength;
            force += -k * x * dir;
        }
    }
    if (j > 0) {
        Particle neighbor = particles[index(i, j-1)];
        vec3 delta = p.position - neighbor.position;
        float dist = length(delta);
        if (dist > 0.0) {
            vec3 dir = delta / dist;
            float x = dist - restLength;
            force += -k * x * dir;
        }
    }
    if (j < NX - 1) {
        Particle neighbor = particles[index(i, j+1)];
        vec3 delta = p.position - neighbor.position;
        float dist = length(delta);
        if (dist > 0.0) {
            vec3 dir = delta / dist;
            float x = dist - restLength;
            force += -k * x * dir;
        }
    }
    
    // Damping (amortissement)
    float damping = 1.0;
    force += -damping * p.velocity;
    
    vec3 accel = force / p.weight;
    
    // Mise à jour de la vitesse et de la position
    p.velocity += accel * dt;
    p.position += p.velocity * dt;
    
    particles[idx] = p;
}